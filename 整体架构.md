# 重构设计思路

> **PanGu Blockchain System**

整体项目的重构原则：所有的数据结构体都有对应的struct和interface接口，一个负责定义数据类型，一个负责实现所有可能需要的方法。

## 交易结构

### 1 交易封皮Cover

交易结构进行重新设计，采用交易外面套一层Cover的结构，而内部的敏感信息对于外人是保密的。

- 首先一个问题是，为什么要加一个Cover？

  因为在现有的以太坊模式下，用户完成一笔交易（调用智能合约）前，这笔交易的所有信息都是公开可见，这就会导致某些恶意节点干扰用户这笔合约调用的正常进行。因此，我们能否将用户调用什么合约，怎么调合约这个过程进行加密？因此就诞生了如今的这个想法，如图所示，Cover部分表明了交易地址，Nonce以及相关必要信息，而最关键的Date，也就是调用智能合约的代码并不在Cover部分，而是放在了加密字段处，外人无法得知具体内容。

- 为什么我们不采用门罗币这种全部信息都加密的方式呢？

  门罗币侧重的是隐私转账，而我们更加关心的是用户执行智能合约时可以在没有隐私泄露的前提下进行，因此我们并不需要完全对所有的信息进行隐藏，而是只隐藏了最关键的Data等信息。

目前暂定的交易结构

```go
// 交易需要缓存的信息
type TransactionCache struct {
    hash atomic.Value
	size atomic.Value
	from atomic.Value
}

// 后续维护扩展可能需要增加的字段，全部都集中于这个结构体中
type TxMisc struct {
    Type byte
    ChainId *big.Int
}

// 单个盘古交易
type PanguTransaction struct {
    // Cover
    TransactionCache	// 缓存
    
    TxMisc	// 后续升级需要增加或修改的字段
    
    Nonce       uint64
    Value       *big.Int
    GasLimit    uint64
    GasPrice    *big.Int

    SenderSigAlgo     byte		// 用户选择的签名算法
    Signature         []byte	// 用户签名
    GuarSigAlgo       byte		// 用户选择的签名算法
    Ensurance         []byte	// 担保人签名

    // 内部信息
    TxContent				// 解密后的交易内容
    EncryptionAlgo  byte	// 加密算法
    EncryptedContent []byte	// 加密后的交易内容
}

// 交易核心内容
type TxContent struct {
    VmType      byte			// 用户选择的虚拟机
    To          *common.Address	// 交易接收地址
    Data        []byte			// 调用合约代码
    AccessList  AccessList		// AccessList
}
```

### 2 担保人

#### 问题来源

区块链交易担保人的提出来源于现实中保险公司的例子。在盘古系统中，由于所有的交易都会按照AccessList分组并执行，对于AccessList与实际执行显示不一样的交易，区块链会进行惩罚性的额外扣费。然而，对于一些用户而言，他们根本就不知道AccessList是什么，怎么写，甚至自己的交易数据是否填写的有问题也不知道。如何解决这个问题？

当然，我们可以提供一个预运行系统，交易在正是发送到区块链前可以在钱包中按照当前的区块链环境先跑一遍来检查错误。但是这样不仅消耗了系统的算力，而且就算出错了，用户也不一定有足够的专业技能去修改出错的原因。因此，我们想到了现实世界中的保险——==我们能不能给交易提供一个保险呢==？

#### 设计思路

在盘古系统中，担保人可以是个人，但我们更倾向于类似于公司一样的形式。用户在发送交易前，如果对自己的交易内容等正确性不放心，担心额外收费的问题，他就可以先将交易发送给担保人。担保人帮助用户修改交易，填写AccessList后，确保该交易没有问题，再将这笔交易进行签名，**之后把交易返回给用户**。用户收到交易后，确认该交易修改等问题后，对整个交易，包括担保人的签名进行签名，之后把交易发送给担保人。担保人统一收集后会将交易进行聚合然后发送到区块链开始执行。

在交易执行过程中，如果交易出错，或者AccessList不符合等种种问题，系统会对交易的汽油费进行额外收取。如果这笔交易被担保，那么这时系统会扣担保人的钱，也就是说，==**一旦一笔交易被担保，那么之后与这笔交易有关的汽油费，惩罚汽油费等都会从担保人这里进行扣除**==。

> 我们把整个过程详细归纳一遍：

1. 用户`User`决定发起一笔交易，由于担心自己的数据可能有问题，并且想要支付更低的汽油费，同时也不在意交易延迟被发送，那么他首先将交易发送到一个自己信任的担保人`G`；
2. 担保人`G`检查用户`User`发过来的交易，修改错误。在检查无误后，他会预执行这笔交易，假设预执行耗费的汽油费为`GasPre`，则担保人`G`会收取该用户`GasGuar = GasPre - GasDecr`作为担保费，其中`GasDecr`是相比于正常执行减少的费用，通常由担保人自己决定；
3. 担保人对检查过的交易进行签名，记为`SignG`，之后回返回给用户User，用户User检查无误后对包括担保人签名在内的整个交易进行签名，记为`SignU`，之后将交易再返回给担保人；
4. 担保人在收集到了足够多的交易后，进行交易聚合，也就是把n个交易打包到一个交易结构中，只在Cover进行签名即可，然后担保人可以将包含多笔交易的交易集合发送到区块链开始执行；
5. 矿工在收到一笔交易后，由于加密机制，他在执行前只能看到`Cover`部分，而通过`Cover`部分无法推断出这笔交易是否是聚合交易，因此矿工会无差别的接收所有的交易开始执行。如果这笔交易是聚合交易，则在执行过程中以更低的汽油费运行，假设在交易正常执行的情况下，交易集合中的单笔交易总的汽油费为`GasPol`，非集合的单笔交易总的汽油费为`GasSignle`，其需要满足不等式`GasPol < GasGuar < GasSignle`，才能保证用户和担保人均可获利；
6. 如果交易出错，则要进行惩罚。如果这笔交易已经被担保，则需要扣除比正常执行更多的汽油费，即已被担保交易扣除汽油费为GasErrPol，未被担保扣除汽油费为GasErrSingle，需要满足`GasErrPol > GasErrSingle > GasPre`。注意，**上述已担保交易扣除的汽油费来源是担保人**，也就是说已担保交易用户只需要支付担保费，之后的汽油费用扣除都与担保人有关，与用户无关。

<img src="./guarantee.png" alt="image-20230901145011559" style="zoom:80%;" />

#### 问题讨论

我们再来细分一下这个过程中可能存在的一些问题：

> 用户为什么要选择担保人，他完全可以直接发送这笔交易

在Pangu系统中，用户选择担保交易，则可以只支付更少的汽油费，但是需要等待更多的时间，因为担保人需要足够多的交易来进行聚合。用户如果不选择担保交易，则他需要支付更多的汽油费，但是不需要等待担保人手机足够的交易进行聚合，可以随时发送交易开始执行。

> 这个过程涉及到的相关费用大小怎么设计才算合理

假设，交易Tx估算运行消耗的汽油费为GasPre，用户支付的担保费为GasGuar；

Tx未担保，正常执行：GasFreeYes

Tx已担保，正常执行：GasGuarYes

Tx未担保，错误执行：GasFreeNo = GasLimit

Tx已担保，错误执行：GasGuarNo

用户通过担保交易一定能比直接交易支付的汽油费少：`GasGuar < GasPre`

已担保的交易在正常情况下可以以更低的汽油费来运行：`GasGuarYes < GasFreeYes`

已担保的交易如果出错需要扣除更多的汽油费：`GasGuarNo > GasFreeNo > GasPre > GasGuar`

理论而言，汽油费价格应该和交易是否担保，聚合交易内的交易数量有关，交易已担保，聚合交易内的交易数量越多，则汽油费价格越低；反之，如果交易出错，交易已担保，聚合交易内的交易数量越多，惩罚的汽油费也就越多。暂定 GasGuarNo = 1.5 * GasFreeNo = 1.5 * GasLimit

> 用户能否在担保人签过名后故意写错数据

担保人对整个交易进行签名，如果用户对交易数据进行修改，就会无法验证签名

> 用户能否自己给自己担保，以获得更低的汽油费价格

当然可以，如果用户自己有能力自己给自己检查交易，预执行交易，用户完全可以自己给自己签名，这时候他就可以以更低的汽油费价格来执行交易。但是，如果交易出错，或者AccessList与实际获得的AccessList不符，根据上述规则，用户需要扣除比未担保错误执行交易更多的汽油费，这种情况下用户实际上比不自己给自己担保亏损的更多。==我们推出担保人机制和交易聚合的本质目的不是为了让某一方赚取更多的或更少的汽油费，而是为了加大系统吞吐量与执行效率，尽可能的防止错误交易导致系统出现的快照回滚等问题==。因此，用户如果自己有能力自己给自己担保，他就可以获得更低的汽油费价格作为奖励，相反的，如果他没有对应的能力却依然自己给自己担保，那么他就要承担交易执行出错导致更大的损失。

### 3 交易聚合

### 4 聚合签名

