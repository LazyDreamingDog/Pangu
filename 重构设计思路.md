# 重构设计思路

> **PanGu Blockchain System**

整体项目的重构原则：所有的数据结构体都有对应的struct和interface接口，一个负责定义数据类型，一个负责实现所有可能需要的方法。

## 交易结构

### 1 交易封皮Cover

交易结构进行重新设计，采用交易外面套一层Cover的结构，而内部的敏感信息对于外人是保密的。

- 首先一个问题是，为什么要加一个Cover？

  因为在现有的以太坊模式下，用户完成一笔交易（调用智能合约）前，这笔交易的所有信息都是公开可见，这就会导致某些恶意节点干扰用户这笔合约调用的正常进行。因此，我们能否将用户调用什么合约，怎么调合约这个过程进行加密？因此就诞生了如今的这个想法，如图所示，Cover部分表明了交易地址，Nonce以及相关必要信息，而最关键的Date，也就是调用智能合约的代码并不在Cover部分，而是放在了加密字段处，外人无法得知具体内容。

- 为什么我们不采用门罗币这种全部信息都加密的方式呢？

  门罗币侧重的是隐私转账，而我们更加关心的是用户执行智能合约时可以在没有隐私泄露的前提下进行，因此我们并不需要完全对所有的信息进行隐藏，而是只隐藏了最关键的Data等信息。

目前暂定的交易结构

```go
// 交易需要缓存的信息
type TransactionCache struct {
    hash atomic.Value
	size atomic.Value
	from atomic.Value
}

// 后续维护扩展可能需要增加的字段，全部都集中于这个结构体中
type TxCoverMisc struct {
    Type byte
    ChainId *big.Int
}

type PanguTransaction struct {
    // Cover
    TransactionCache
    TxCoverMisc
    
    Nonce       uint64
    Value       *big.Int
    Gas         uint64
    GasPrice    *big.Int

    SenderSigAlgo     byte		// 用户选择的签名算法
    Signature         []byte	// 用户签名
    GuarSigAlgo       byte		// 用户选择的签名算法
    Ensurance         []byte	// 担保人签名

    // 内部信息
    TxContent				// 解密后的交易内容
    EncryptionAlgo  byte	// 加密算法
    EncryptedContent []byte	// 加密后的交易内容
}

// 交易核心内容
type TxContent struct {
    VmType      byte			// 用户选择的虚拟机
    To          *common.Address	// 交易接收地址
    Data        []byte			// 调用合约代码
    AccessList  AccessList		// AccessList
}
```

### 2 担保人

区块链交易担保人的提出来源于现实中保险公司的例子。在盘古系统中，由于所有的交易都会按照AccessList分组并执行，对于AccessList与实际执行显示不一样的交易，区块链会进行惩罚性的额外扣费。然而，对于一些用户而言，他们根本就不知道AccessList是什么，怎么写，甚至自己的交易数据是否填写的有问题也不知道。如何解决这个问题？

当然，我们可以提供一个预运行系统，交易在正是发送到区块链前可以在钱包中按照当前的区块链环境先跑一遍来检查错误。但是这样不仅消耗了系统的算力，而且就算出错了，用户也不一定有足够的专业技能去修改出错的原因。因此，我们想到了现实世界中的保险——==我们能不能给交易提供一个保险呢==？

在盘古系统中，担保人可以是个人，但我们更倾向于类似于公司一样的形式。用户在发送交易前，如果对自己的交易内容等正确性不放心，担心额外收费的问题，他就可以先将交易发送给担保人。担保人帮助用户修改交易，填写AccessList后，确保该交易没有问题，再将这笔交易进行签名，**之后把交易返回给用户**。用户收到交易后，确认该交易修改等问题后，对整个交易，包括担保人的签名进行签名，之后把交易发送给区块链。

在交易执行过程中，如果交易出错，或者AccessList不符合等种种问题，系统会对用户的汽油费进行额外收取。如果这笔交易被担保，那么这时系统会扣担保人的钱，也就是说，==**一旦一笔交易被担保，那么之后与这笔交易有关的汽油费，惩罚汽油费等都会从担保人这里进行扣除**==。

> 交易的主体依然是用户，担保人只是起到了一个中间人的作用。

我们再来细分一下这个过程中可能存在的一些问题：

- 用户为什么要选择担保人，他完全可以直接发送这笔交易

用户选择担保人的原因主要是因为：用户不懂，或者担心自己的交易数据填写有问题，但是又不想承担由于错误交易导致的额外汽油费损耗。那么他就可以找担保人进行担保，这样如果出错了，汽油费都会从担保人那里扣除，自己不需要承担额外的错误汽油费。

用户当然可以直接发送这笔交易，这样做的好处在于发送交易前不再需要担保人签名，省去了担保人的费用，但是缺点在于如果出现了错误，**额外产生的汽油费需要由用户自己承担，且无法得到任何赔偿**。

- 交易如果出错，担保人应该赔付用户多少钱

我们来算一笔账：

用户不担保，直接发送交易，如果不出错，假设消耗的汽油费为`a`；

用户不担保，直接发送交易，如果出错了，假设消耗的汽油费为`a+b` <= gaslimit；

用户担保，如果不出错，假设消耗的汽油费为a，消耗的担保费为`c`，总消耗为`a+c`；

用户担保，交易出错，假设消耗的汽油费为a+b，消耗的担保费为`c`，总消耗为`a+b+c`；

如果交易本来没有错，那么担保的用户相比没有担保的用户会额外损失担保费`c`；

如果交易本来就有错，那么担保的用户消耗`a+b+c`，没有担保的用户消耗`a+b`，担保人赔偿给担保的用户`d`，那么至少要满足`d>c`，用户才有可能找担保公司做担保。

> 用户给担保人的担保费 `<` 这笔交易正常运行时预估产生的汽油费

只有这种情况下，用户才可能通过担保人来担保交易。

具体的数值可能要后续通过详细的数学建模才能大概了解，现在方案中只需要满足d>c即可保证担保用户的权益。

- 用户能否在担保人签过名后故意写错数据达到骗保的目的

担保人对整个交易进行签名，如果用户对交易数据进行修改，就会无法验证签名。

### 3 交易聚合

### 4 聚合签名

